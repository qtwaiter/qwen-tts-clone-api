<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Qwen å£°éŸ³å…‹éš†</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }
        .container {
            max-width: 800px;
            margin: 0 auto;
        }
        h1 {
            text-align: center;
            color: white;
            margin-bottom: 30px;
            font-size: 2.5em;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.2);
        }
        .card {
            background: white;
            border-radius: 16px;
            padding: 24px;
            margin-bottom: 20px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
        }
        .card h2 {
            color: #333;
            margin-bottom: 16px;
            font-size: 1.3em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }
        .form-group {
            margin-bottom: 16px;
        }
        label {
            display: block;
            margin-bottom: 6px;
            color: #555;
            font-weight: 500;
        }
        input[type="text"],
        input[type="password"],
        textarea,
        select {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }
        input:focus, textarea:focus, select:focus {
            outline: none;
            border-color: #667eea;
        }
        textarea {
            min-height: 100px;
            resize: vertical;
        }
        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: transform 0.2s, box-shadow 0.2s;
        }
        .btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-danger {
            background: #dc3545;
        }
        .btn-success {
            background: #28a745;
        }
        .file-input-wrapper {
            position: relative;
            overflow: hidden;
            display: inline-block;
        }
        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }
        .file-label {
            display: inline-block;
            padding: 12px 24px;
            background: #f8f9fa;
            border: 2px dashed #667eea;
            border-radius: 8px;
            cursor: pointer;
            color: #667eea;
            font-weight: 500;
            transition: all 0.3s;
        }
        .file-label:hover {
            background: #e9ecef;
        }
        .audio-preview {
            margin-top: 12px;
            padding: 12px;
            background: #f8f9fa;
            border-radius: 8px;
        }
        .voice-list {
            max-height: 300px;
            overflow-y: auto;
        }
        .voice-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px;
            border-bottom: 1px solid #eee;
        }
        .voice-item:last-child {
            border-bottom: none;
        }
        .voice-info {
            flex: 1;
        }
        .voice-name {
            font-weight: 600;
            color: #333;
        }
        .voice-id {
            font-size: 12px;
            color: #888;
            font-family: monospace;
            word-break: break-all;
        }
        .voice-actions {
            display: flex;
            gap: 8px;
        }
        .btn-small {
            padding: 6px 12px;
            font-size: 12px;
        }
        .log {
            background: #1e1e1e;
            color: #d4d4d4;
            padding: 16px;
            border-radius: 8px;
            font-family: 'Consolas', 'Monaco', monospace;
            font-size: 13px;
            max-height: 300px;
            overflow-y: auto;
            margin-top: 16px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .log-entry {
            margin-bottom: 8px;
            padding: 4px 0;
            border-bottom: 1px solid #333;
        }
        .log-entry:last-child {
            border-bottom: none;
        }
        .log-entry.error { color: #f48771; }
        .log-entry.success { color: #89d185; }
        .log-entry.info { color: #4fc1ff; }
        .log-entry.warning { color: #dcdcaa; }
        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid rgba(255,255,255,.3);
            border-radius: 50%;
            border-top-color: white;
            animation: spin 1s ease-in-out infinite;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        .tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 20px;
            flex-wrap: wrap;
        }
        .tab {
            padding: 10px 20px;
            background: rgba(255,255,255,0.2);
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s;
        }
        .tab.active {
            background: white;
            color: #667eea;
        }
        .tab-content {
            display: none;
        }
        .tab-content.active {
            display: block;
        }
        .result-audio {
            margin-top: 16px;
            padding: 16px;
            background: #e8f5e9;
            border-radius: 8px;
            text-align: center;
        }
        .result-audio audio {
            width: 100%;
            margin-top: 8px;
        }
        .empty-state {
            text-align: center;
            padding: 40px;
            color: #888;
        }
        .tips {
            background: #fff3cd;
            border-left: 4px solid #ffc107;
            padding: 12px 16px;
            margin-bottom: 16px;
            border-radius: 0 8px 8px 0;
        }
        .tips ul {
            margin-left: 20px;
            margin-top: 8px;
        }
        .tips li {
            margin-bottom: 4px;
        }
        .debug-info {
            background: #f8f9fa;
            border: 1px solid #ddd;
            padding: 12px;
            border-radius: 8px;
            margin-top: 16px;
            font-family: monospace;
            font-size: 12px;
        }
        .debug-info h3 {
            margin-bottom: 8px;
            color: #666;
        }
        .status-badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            font-weight: 600;
            margin-left: 8px;
        }
        .status-badge.ok {
            background: #28a745;
            color: white;
        }
        .status-badge.error {
            background: #dc3545;
            color: white;
        }
        .status-badge.warning {
            background: #ffc107;
            color: #333;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸ™ï¸ Qwen å£°éŸ³å…‹éš†</h1>
        
        <div class="tabs">
            <button class="tab active" onclick="switchTab('create')">åˆ›å»ºéŸ³è‰²</button>
            <button class="tab" onclick="switchTab('list')">æˆ‘çš„éŸ³è‰²</button>
            <button class="tab" onclick="switchTab('synthesize')">è¯­éŸ³åˆæˆ</button>
            <button class="tab" onclick="switchTab('settings')">è®¾ç½®</button>
        </div>

        <!-- åˆ›å»ºéŸ³è‰² -->
        <div id="create" class="tab-content active">
            <div class="card">
                <h2>åˆ›å»ºæ–°éŸ³è‰²</h2>
                <div class="tips">
                    <strong>éŸ³é¢‘è¦æ±‚ï¼š</strong>
                    <ul>
                        <li>æ ¼å¼ï¼šWAV (16bit)ã€MP3ã€M4A</li>
                        <li>æ—¶é•¿ï¼šæ¨è 10-20 ç§’ï¼Œæœ€é•¿ä¸è¶…è¿‡ 60 ç§’</li>
                        <li>å¤§å°ï¼šå°äº 10 MB</li>
                        <li>é‡‡æ ·ç‡ï¼šâ‰¥ 24 kHzï¼Œå•å£°é“</li>
                        <li>å†…å®¹ï¼šæ¸…æ™°æœ—è¯»ï¼Œæ— èƒŒæ™¯éŸ³ã€å™ªéŸ³æˆ–å…¶ä»–äººå£°</li>
                    </ul>
                </div>
                <div class="form-group">
                    <label>éŸ³è‰²åç§°ï¼ˆç”¨äºè¯†åˆ«ï¼‰</label>
                    <input type="text" id="voiceName" placeholder="ä¾‹å¦‚ï¼šmy_voice_01" maxlength="16">
                </div>
                <div class="form-group">
                    <label>ä¸Šä¼ éŸ³é¢‘æ ·æœ¬</label>
                    <div class="file-input-wrapper">
                        <input type="file" id="audioFile" accept=".wav,.mp3,.m4a,audio/*">
                        <label for="audioFile" class="file-label">ğŸ“ é€‰æ‹©éŸ³é¢‘æ–‡ä»¶</label>
                    </div>
                    <div id="audioPreview" class="audio-preview" style="display:none;">
                        <div>å·²é€‰æ‹©: <span id="fileName"></span></div>
                        <audio id="previewPlayer" controls style="margin-top:8px;width:100%;"></audio>
                    </div>
                </div>
                <button class="btn" id="createBtn" onclick="createVoice()">
                    <span id="createBtnText">åˆ›å»ºéŸ³è‰²</span>
                </button>
                <div id="createResult"></div>
            </div>
        </div>

        <!-- éŸ³è‰²åˆ—è¡¨ -->
        <div id="list" class="tab-content">
            <div class="card">
                <h2>æˆ‘çš„éŸ³è‰²åˆ—è¡¨</h2>
                <button class="btn btn-secondary" onclick="loadVoiceList()">ğŸ”„ åˆ·æ–°åˆ—è¡¨</button>
                <div id="voiceList" class="voice-list" style="margin-top:16px;">
                    <div class="empty-state">ç‚¹å‡»åˆ·æ–°æŒ‰é’®åŠ è½½éŸ³è‰²åˆ—è¡¨</div>
                </div>
            </div>
        </div>

        <!-- è¯­éŸ³åˆæˆ -->
        <div id="synthesize" class="tab-content">
            <div class="card">
                <h2>è¯­éŸ³åˆæˆ</h2>
                <div class="form-group">
                    <label>é€‰æ‹©éŸ³è‰²</label>
                    <select id="synthesisVoice">
                        <option value="">è¯·å…ˆåˆ›å»ºéŸ³è‰²</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>è¾“å…¥æ–‡æœ¬</label>
                    <textarea id="synthesisText" placeholder="è¯·è¾“å…¥è¦åˆæˆçš„æ–‡æœ¬..."></textarea>
                </div>
                <button class="btn" id="synthesizeBtn" onclick="synthesize()">
                    <span id="synthesizeBtnText">å¼€å§‹åˆæˆ</span>
                </button>
                <div id="synthesisResult"></div>
            </div>
        </div>

        <!-- è®¾ç½® -->
        <div id="settings" class="tab-content">
            <div class="card">
                <h2>API è®¾ç½®</h2>
                <div class="form-group">
                    <label>DashScope API Key <span id="apiKeyStatus" class="status-badge">æœªè®¾ç½®</span></label>
                    <input type="password" id="apiKey" placeholder="sk-xxxxxxxxxxxxxxxxxxxxxxxx" autocomplete="off">
                    <small style="color:#888;">ä½ çš„ API Key ä»…å­˜å‚¨åœ¨æœ¬åœ°æµè§ˆå™¨ä¸­</small>
                </div>
                <div class="form-group">
                    <label>æœåŠ¡åœ°åŸŸ</label>
                    <select id="region">
                        <option value="cn">ä¸­å›½å†…åœ°ï¼ˆåŒ—äº¬ï¼‰</option>
                        <option value="intl">å›½é™…ç«™ï¼ˆæ–°åŠ å¡ï¼‰</option>
                    </select>
                    <small style="color:#888;">è¯·ç¡®ä¿ API Key ä¸é€‰æ‹©çš„åœ°åŸŸå¯¹åº”</small>
                </div>
                <div class="form-group">
                    <label>è¯­éŸ³åˆæˆæ¨¡å‹</label>
                    <select id="targetModel">
                        <option value="qwen3-tts-vc-realtime-2026-01-15">qwen3-tts-vc-realtime-2026-01-15ï¼ˆæ¨èï¼‰</option>
                        <option value="qwen3-tts-vc-realtime-2025-11-27">qwen3-tts-vc-realtime-2025-11-27</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="useProxy" style="margin-right:8px;">
                        ä½¿ç”¨ CORS ä»£ç†ï¼ˆè§£å†³ HTTP API è·¨åŸŸé—®é¢˜ï¼‰
                    </label>
                    <small style="color:#888;">å‹¾é€‰åä½¿ç”¨ä»£ç†æœåŠ¡å™¨è½¬å‘ HTTP è¯·æ±‚</small>
                </div>
                <div class="form-group">
                    <label>WebSocket ä»£ç†åœ°å€ï¼ˆå¯é€‰ï¼‰</label>
                    <input type="text" id="wsProxyUrl" placeholder="ws://localhost:3001/proxy" value="ws://localhost:3001/proxy">
                    <small style="color:#888;">ç•™ç©ºåˆ™ç›´æ¥è¿æ¥é˜¿é‡Œäº‘æœåŠ¡å™¨ã€‚å¦‚æœé‡åˆ° WebSocket è·¨åŸŸé—®é¢˜ï¼Œè¯·å…ˆè¿è¡Œä»£ç†æœåŠ¡å™¨ï¼š<code>npm run install-deps && npm start</code></small>
                </div>
                <button class="btn btn-success" onclick="saveSettings()">ä¿å­˜è®¾ç½®</button>
                <button class="btn btn-secondary" onclick="testConnection()" style="margin-left:8px;">æµ‹è¯•è¿æ¥</button>
            </div>
            
            <div class="card">
                <h2>è¿è¡Œæ—¥å¿—</h2>
                <div id="log" class="log"></div>
                <button class="btn btn-secondary btn-small" onclick="clearLog()" style="margin-top:8px;">æ¸…ç©ºæ—¥å¿—</button>
                <button class="btn btn-secondary btn-small" onclick="exportLog()" style="margin-left:8px;">å¯¼å‡ºæ—¥å¿—</button>
            </div>
        </div>
    </div>

    <script>
        // é…ç½®
        const CONFIG = {
            cn: {
                httpUrl: 'https://dashscope.aliyuncs.com/api/v1/services/audio/tts/customization',
                wsUrl: 'wss://dashscope.aliyuncs.com/api-ws/v1/realtime'
            },
            intl: {
                httpUrl: 'https://dashscope-intl.aliyuncs.com/api/v1/services/audio/tts/customization',
                wsUrl: 'wss://dashscope-intl.aliyuncs.com/api-ws/v1/realtime'
            },
            proxy: {
                enabled: localStorage.getItem('qwen_use_proxy') === 'true',
                httpProxy: 'https://corsproxy.io/?',
                wsProxy: null // WebSocket ä¸æ”¯æŒæ ‡å‡†ä»£ç†
            }
        };

        // çŠ¶æ€
        let currentAudioFile = null;
        let ws = null;
        let audioContext = null;
        let audioQueue = [];
        let isPlaying = false;

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', () => {
            log('é¡µé¢åŠ è½½å®Œæˆ', 'info');
            log(`å½“å‰URL: ${window.location.href}`, 'info');
            checkBrowserSupport();
            loadSettings();
            setupFileInput();
        });

        function checkBrowserSupport() {
            const features = {
                'File API': typeof FileReader !== 'undefined',
                'WebSocket': typeof WebSocket !== 'undefined',
                'AudioContext': typeof (window.AudioContext || window.webkitAudioContext) !== 'undefined',
                'localStorage': typeof localStorage !== 'undefined'
            };
            
            log('æµè§ˆå™¨ç‰¹æ€§æ£€æŸ¥:', 'info');
            for (const [feature, supported] of Object.entries(features)) {
                const status = supported ? 'âœ“' : 'âœ—';
                const type = supported ? 'success' : 'error';
                log(`  ${status} ${feature}`, type);
            }
            
            const allSupported = Object.values(features).every(v => v);
            if (allSupported) {
                log('âœ“ æ‰€æœ‰å¿…éœ€çš„æµè§ˆå™¨ç‰¹æ€§éƒ½æ”¯æŒ', 'success');
            } else {
                log('âœ— éƒ¨åˆ†æµè§ˆå™¨ç‰¹æ€§ä¸æ”¯æŒï¼Œå¯èƒ½å½±å“åŠŸèƒ½', 'warning');
            }
        }

        // æ ‡ç­¾åˆ‡æ¢
        function switchTab(tabName) {
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(t => t.classList.remove('active'));
            event.target.classList.add('active');
            document.getElementById(tabName).classList.add('active');
            
            if (tabName === 'list') loadVoiceList();
            if (tabName === 'synthesize') updateVoiceSelect();
        }

        // è®¾ç½®
        function loadSettings() {
            const apiKey = localStorage.getItem('qwen_api_key') || '';
            const region = localStorage.getItem('qwen_region') || 'cn';
            const model = localStorage.getItem('qwen_model') || 'qwen3-tts-vc-realtime-2026-01-15';
            const useProxy = localStorage.getItem('qwen_use_proxy') === 'true';
            const wsProxyUrl = localStorage.getItem('qwen_ws_proxy_url') || 'ws://localhost:3001/proxy';
            document.getElementById('apiKey').value = apiKey;
            document.getElementById('region').value = region;
            document.getElementById('targetModel').value = model;
            document.getElementById('useProxy').checked = useProxy;
            document.getElementById('wsProxyUrl').value = wsProxyUrl;
            CONFIG.proxy.enabled = useProxy;
            updateApiKeyStatus(apiKey);
        }

        function saveSettings() {
            const apiKey = document.getElementById('apiKey').value.trim();
            localStorage.setItem('qwen_api_key', apiKey);
            localStorage.setItem('qwen_region', document.getElementById('region').value);
            localStorage.setItem('qwen_model', document.getElementById('targetModel').value);
            localStorage.setItem('qwen_use_proxy', document.getElementById('useProxy').checked);
            localStorage.setItem('qwen_ws_proxy_url', document.getElementById('wsProxyUrl').value);
            CONFIG.proxy.enabled = document.getElementById('useProxy').checked;
            updateApiKeyStatus(apiKey);
            log('è®¾ç½®å·²ä¿å­˜', 'success');
        }

        function getSettings() {
            return {
                apiKey: localStorage.getItem('qwen_api_key') || '',
                region: localStorage.getItem('qwen_region') || 'cn',
                model: localStorage.getItem('qwen_model') || 'qwen3-tts-vc-realtime-2026-01-15',
                useProxy: localStorage.getItem('qwen_use_proxy') === 'true',
                wsProxyUrl: localStorage.getItem('qwen_ws_proxy_url') || 'ws://localhost:3001/proxy'
            };
        }

        // ä»£ç† URL è½¬æ¢
        function getProxiedUrl(url) {
            const settings = getSettings();
            if (settings.useProxy && url.startsWith('https://')) {
                log(`ä½¿ç”¨ä»£ç†: ${CONFIG.proxy.httpProxy}${encodeURIComponent(url)}`, 'info');
                return CONFIG.proxy.httpProxy + encodeURIComponent(url);
            }
            return url;
        }

        function updateApiKeyStatus(apiKey) {
            const statusEl = document.getElementById('apiKeyStatus');
            if (!apiKey) {
                statusEl.textContent = 'æœªè®¾ç½®';
                statusEl.className = 'status-badge error';
            } else if (apiKey.startsWith('sk-') && apiKey.length > 20) {
                statusEl.textContent = 'å·²è®¾ç½®';
                statusEl.className = 'status-badge ok';
            } else {
                statusEl.textContent = 'æ ¼å¼å¼‚å¸¸';
                statusEl.className = 'status-badge warning';
            }
        }

        // æµ‹è¯•è¿æ¥
        async function testConnection() {
            const settings = getSettings();
            
            if (!settings.apiKey) {
                alert('è¯·å…ˆè®¾ç½® API Key');
                return;
            }

            log('å¼€å§‹æµ‹è¯• API è¿æ¥...', 'info');
            log(`API Key: ${settings.apiKey.substring(0, 10)}...`, 'info');
            log(`åœ°åŸŸ: ${settings.region}`, 'info');

            try {
                const startTime = Date.now();
                const url = getProxiedUrl(CONFIG[settings.region].httpUrl);
                log(`è¯·æ±‚URL: ${url}`, 'info');
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${settings.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'qwen-voice-enrollment',
                        input: {
                            action: 'list',
                            page_size: 1,
                            page_index: 0
                        }
                    })
                });

                const duration = Date.now() - startTime;
                log(`è¯·æ±‚è€—æ—¶: ${duration}ms`, 'info');
                log(`HTTPçŠ¶æ€ç : ${response.status}`, response.ok ? 'success' : 'warning');

                const contentType = response.headers.get('content-type');
                log(`å“åº”ç±»å‹: ${contentType}`, 'info');

                const data = await response.json();
                log(`å®Œæ•´å“åº”: ${JSON.stringify(data, null, 2)}`, 'info');

                if (response.ok) {
                    log('âœ“ API è¿æ¥æµ‹è¯•æˆåŠŸï¼', 'success');
                    alert('è¿æ¥æµ‹è¯•æˆåŠŸï¼API Key å’Œåœ°åŸŸé…ç½®æ­£ç¡®ã€‚');
                } else {
                    log(`âœ— API è¯·æ±‚å¤±è´¥: ${response.status}`, 'error');
                    log(`é”™è¯¯ä¿¡æ¯: ${data.message || JSON.stringify(data)}`, 'error');
                    alert(`è¿æ¥æµ‹è¯•å¤±è´¥\nHTTP ${response.status}\n${data.message || JSON.stringify(data)}`);
                }
            } catch (error) {
                log(`âœ— è¿æ¥æµ‹è¯•å¤±è´¥: ${error.message}`, 'error');
                log(`é”™è¯¯è¯¦æƒ…: ${error.stack}`, 'error');
                
                // è¯Šæ–­ä¿¡æ¯
                log('\n=== è¯Šæ–­ä¿¡æ¯ ===', 'warning');
                log(`å½“å‰URL: ${window.location.href}`, 'info');
                log(`æ˜¯å¦HTTPS: ${window.location.protocol === 'https:'}`, 'info');
                log(`User Agent: ${navigator.userAgent}`, 'info');
                
                alert(`è¿æ¥æµ‹è¯•å¤±è´¥\né”™è¯¯: ${error.message}\n\nè¯·æ£€æŸ¥ï¼š\n1. API Key æ˜¯å¦æ­£ç¡®\n2. ç½‘ç»œè¿æ¥æ˜¯å¦æ­£å¸¸\n3. æ˜¯å¦é€šè¿‡æœ¬åœ°æœåŠ¡å™¨è®¿é—®ï¼ˆlocalhost æˆ– 127.0.0.1ï¼‰\n\nè¯¦ç»†é”™è¯¯ä¿¡æ¯å·²æ˜¾ç¤ºåœ¨æ—¥å¿—ä¸­`);
            }
        }

        // æ–‡ä»¶è¾“å…¥
        function setupFileInput() {
            document.getElementById('audioFile').addEventListener('change', (e) => {
                const file = e.target.files[0];
                if (file) {
                    currentAudioFile = file;
                    document.getElementById('fileName').textContent = file.name;
                    document.getElementById('audioPreview').style.display = 'block';
                    const url = URL.createObjectURL(file);
                    document.getElementById('previewPlayer').src = url;
                    log(`å·²é€‰æ‹©æ–‡ä»¶: ${file.name} (${(file.size/1024/1024).toFixed(2)} MB)`, 'info');
                    log(`æ–‡ä»¶ç±»å‹: ${file.type || 'æœªçŸ¥'}`, 'info');
                }
            });
        }

        // æ—¥å¿—
        function log(message, type = 'info') {
            const logEl = document.getElementById('log');
            const entry = document.createElement('div');
            entry.className = `log-entry ${type}`;
            entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`;
            logEl.appendChild(entry);
            logEl.scrollTop = logEl.scrollHeight;
        }

        function clearLog() {
            document.getElementById('log').innerHTML = '';
        }

        function exportLog() {
            const logText = document.getElementById('log').innerText;
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `qwen-log-${Date.now()}.txt`;
            a.click();
        }

        // åˆ›å»ºéŸ³è‰²
        async function createVoice() {
            const settings = getSettings();
            
            if (!settings.apiKey) {
                alert('è¯·å…ˆè®¾ç½® API Key');
                switchTab('settings');
                return;
            }
            if (!currentAudioFile) {
                alert('è¯·é€‰æ‹©éŸ³é¢‘æ–‡ä»¶');
                return;
            }
            const voiceName = document.getElementById('voiceName').value.trim() || 'custom_voice';

            const btn = document.getElementById('createBtn');
            const btnText = document.getElementById('createBtnText');
            btn.disabled = true;
            btnText.innerHTML = '<span class="loading"></span> åˆ›å»ºä¸­...';

            try {
                log('\n=== å¼€å§‹åˆ›å»ºéŸ³è‰² ===', 'info');
                log(`éŸ³è‰²åç§°: ${voiceName}`, 'info');
                log(`ç›®æ ‡æ¨¡å‹: ${settings.model}`, 'info');
                log(`API URL: ${CONFIG[settings.region].httpUrl}`, 'info');
                
                log('è¯»å–éŸ³é¢‘æ–‡ä»¶...', 'info');
                const base64Audio = await fileToBase64(currentAudioFile);
                const mimeType = currentAudioFile.type || 'audio/mpeg';
                const dataUri = `data:${mimeType};base64,${base64Audio}`;
                log(`éŸ³é¢‘Base64é•¿åº¦: ${base64Audio.length} å­—ç¬¦`, 'info');
                log(`MIMEç±»å‹: ${mimeType}`, 'info');

                log('å‘é€ API è¯·æ±‚...', 'info');
                const startTime = Date.now();
                const url = getProxiedUrl(CONFIG[settings.region].httpUrl);
                log(`è¯·æ±‚URL: ${url}`, 'info');
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${settings.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'qwen-voice-enrollment',
                        input: {
                            action: 'create',
                            target_model: settings.model,
                            preferred_name: voiceName,
                            audio: { data: dataUri }
                        }
                    })
                });

                const duration = Date.now() - startTime;
                log(`è¯·æ±‚å®Œæˆï¼Œè€—æ—¶: ${duration}ms`, 'info');
                log(`HTTPçŠ¶æ€ç : ${response.status}`, response.ok ? 'success' : 'warning');

                const responseText = await response.text();
                log(`å“åº”å†…å®¹: ${responseText}`, 'info');

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${responseText}`);
                }

                const data = JSON.parse(responseText);
                
                if (data.output?.voice) {
                    const voiceId = data.output.voice;
                    log(`\nâœ“ éŸ³è‰²åˆ›å»ºæˆåŠŸ!`, 'success');
                    log(`Voice ID: ${voiceId}`, 'success');
                    document.getElementById('createResult').innerHTML = `
                        <div class="result-audio">
                            <div style="color:#2e7d32;font-weight:600;">âœ… éŸ³è‰²åˆ›å»ºæˆåŠŸï¼</div>
                            <div style="margin-top:8px;font-family:monospace;font-size:12px;word-break:break-all;">${voiceId}</div>
                            <div style="margin-top:8px;color:#666;">ç°åœ¨å¯ä»¥ä½¿ç”¨è¿™ä¸ªéŸ³è‰²è¿›è¡Œè¯­éŸ³åˆæˆäº†</div>
                        </div>
                    `;
                    saveVoiceToList(voiceId, voiceName, settings.model);
                } else {
                    throw new Error('å“åº”ä¸­æœªæ‰¾åˆ° voice å­—æ®µ');
                }
            } catch (error) {
                log(`\nâœ— åˆ›å»ºå¤±è´¥: ${error.message}`, 'error');
                log(`é”™è¯¯è¯¦æƒ…: ${error.stack}`, 'error');
                
                document.getElementById('createResult').innerHTML = `
                    <div class="result-audio" style="background:#ffebee;">
                        <div style="color:#c62828;">âŒ åˆ›å»ºå¤±è´¥</div>
                        <div style="margin-top:8px;font-family:monospace;font-size:12px;">${error.message}</div>
                        <div style="margin-top:8px;font-size:12px;color:#666;">è¯·æŸ¥çœ‹æ—¥å¿—è·å–è¯¦ç»†é”™è¯¯ä¿¡æ¯</div>
                    </div>
                `;
            } finally {
                btn.disabled = false;
                btnText.textContent = 'åˆ›å»ºéŸ³è‰²';
            }
        }

        function fileToBase64(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = () => {
                    const base64 = reader.result.split(',')[1];
                    resolve(base64);
                };
                reader.onerror = (error) => {
                    log(`æ–‡ä»¶è¯»å–å¤±è´¥: ${error}`, 'error');
                    reject(error);
                };
                reader.readAsDataURL(file);
            });
        }

        // æœ¬åœ°éŸ³è‰²ç®¡ç†
        function getVoiceList() {
            return JSON.parse(localStorage.getItem('qwen_voice_list') || '[]');
        }

        function saveVoiceToList(voiceId, name, model) {
            const list = getVoiceList();
            list.unshift({ voiceId, name, model, createdAt: new Date().toISOString() });
            localStorage.setItem('qwen_voice_list', JSON.stringify(list));
        }

        function removeVoiceFromList(voiceId) {
            let list = getVoiceList();
            list = list.filter(v => v.voiceId !== voiceId);
            localStorage.setItem('qwen_voice_list', JSON.stringify(list));
        }

        // æŸ¥è¯¢éŸ³è‰²åˆ—è¡¨ï¼ˆä»APIè·å–ï¼‰
        async function loadVoiceList() {
            const settings = getSettings();
            if (!settings.apiKey) {
                document.getElementById('voiceList').innerHTML = '<div class="empty-state">è¯·å…ˆè®¾ç½® API Key</div>';
                return;
            }

            document.getElementById('voiceList').innerHTML = '<div class="empty-state">åŠ è½½ä¸­...</div>';

            try {
                log('åŠ è½½éŸ³è‰²åˆ—è¡¨...', 'info');
                const url = getProxiedUrl(CONFIG[settings.region].httpUrl);
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${settings.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'qwen-voice-enrollment',
                        input: {
                            action: 'list',
                            page_size: 100,
                            page_index: 0
                        }
                    })
                });

                const data = await response.json();
                log(`åŠ è½½å®Œæˆ: ${JSON.stringify(data)}`, 'info');

                if (response.ok && data.output?.voice_list) {
                    const voices = data.output.voice_list;
                    if (voices.length === 0) {
                        document.getElementById('voiceList').innerHTML = '<div class="empty-state">æš‚æ— éŸ³è‰²ï¼Œè¯·å…ˆåˆ›å»º</div>';
                        return;
                    }
                    renderVoiceList(voices);
                    log(`âœ“ æˆåŠŸåŠ è½½ ${voices.length} ä¸ªéŸ³è‰²`, 'success');
                } else {
                    throw new Error(data.message || 'è·å–å¤±è´¥');
                }
            } catch (error) {
                log(`åŠ è½½å¤±è´¥: ${error.message}`, 'error');
                document.getElementById('voiceList').innerHTML = `<div class="empty-state" style="color:#c62828;">åŠ è½½å¤±è´¥: ${error.message}</div>`;
            }
        }

        function renderVoiceList(voices) {
            const html = voices.map(v => `
                <div class="voice-item">
                    <div class="voice-info">
                        <div class="voice-name">${v.voice}</div>
                        <div class="voice-id">æ¨¡å‹: ${v.target_model} | åˆ›å»º: ${v.gmt_create}</div>
                    </div>
                    <div class="voice-actions">
                        <button class="btn btn-success btn-small" onclick="useVoice('${v.voice}')">ä½¿ç”¨</button>
                        <button class="btn btn-danger btn-small" onclick="deleteVoice('${v.voice}')">åˆ é™¤</button>
                    </div>
                </div>
            `).join('');
            document.getElementById('voiceList').innerHTML = html;
        }

        async function deleteVoice(voiceId) {
            if (!confirm(`ç¡®å®šè¦åˆ é™¤éŸ³è‰² "${voiceId}" å—ï¼Ÿ`)) return;
            
            const settings = getSettings();
            try {
                const url = getProxiedUrl(CONFIG[settings.region].httpUrl);
                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Authorization': `Bearer ${settings.apiKey}`,
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        model: 'qwen-voice-enrollment',
                        input: {
                            action: 'delete',
                            voice: voiceId
                        }
                    })
                });

                if (response.ok) {
                    log(`éŸ³è‰²å·²åˆ é™¤: ${voiceId}`, 'success');
                    removeVoiceFromList(voiceId);
                    loadVoiceList();
                } else {
                    throw new Error('åˆ é™¤å¤±è´¥');
                }
            } catch (error) {
                log(`åˆ é™¤å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function useVoice(voiceId) {
            document.getElementById('synthesisVoice').value = voiceId;
            switchTab('synthesize');
            log(`å·²é€‰æ‹©éŸ³è‰²: ${voiceId}`);
        }

        function updateVoiceSelect() {
            const select = document.getElementById('synthesisVoice');
            const localVoices = getVoiceList();
            
            if (localVoices.length === 0) {
                select.innerHTML = '<option value="">æš‚æ— éŸ³è‰²ï¼Œè¯·å…ˆåˆ›å»º</option>';
                return;
            }
            
            select.innerHTML = localVoices.map(v => 
                `<option value="${v.voiceId}">${v.name} (${v.voiceId.substring(0, 30)}...)</option>`
            ).join('');
        }

        // è¯­éŸ³åˆæˆï¼ˆWebSocketï¼‰
        async function synthesize() {
            const settings = getSettings();
            const voiceId = document.getElementById('synthesisVoice').value;
            const text = document.getElementById('synthesisText').value.trim();

            if (!settings.apiKey) {
                alert('è¯·å…ˆè®¾ç½® API Key');
                return;
            }
            if (!voiceId) {
                alert('è¯·é€‰æ‹©éŸ³è‰²');
                return;
            }
            if (!text) {
                alert('è¯·è¾“å…¥æ–‡æœ¬');
                return;
            }

            const btn = document.getElementById('synthesizeBtn');
            const btnText = document.getElementById('synthesizeBtnText');
            btn.disabled = true;
            btnText.innerHTML = '<span class="loading"></span> åˆæˆä¸­...';
            document.getElementById('synthesisResult').innerHTML = '';

            // å…³é—­ä¹‹å‰çš„è¿æ¥
            if (ws) {
                ws.close();
                ws = null;
            }

            audioQueue = [];
            isPlaying = false;

            try {
                log('\n=== å¼€å§‹è¯­éŸ³åˆæˆ ===', 'info');
                log(`Voice ID: ${voiceId}`, 'info');
                log(`æ–‡æœ¬é•¿åº¦: ${text.length} å­—ç¬¦`, 'info');
                
                // æ£€æŸ¥æ˜¯å¦ä½¿ç”¨ WebSocket ä»£ç†
                const useWsProxy = settings.wsProxyUrl && settings.wsProxyUrl.trim() !== '';
                let wsUrl;
                
                if (useWsProxy) {
                    wsUrl = `${settings.wsProxyUrl}?url=${encodeURIComponent(CONFIG[settings.region].wsUrl)}&api_key=${encodeURIComponent(settings.apiKey)}&model=${settings.model}`;
                    log(`ä½¿ç”¨ WebSocket ä»£ç†`, 'info');
                } else {
                    wsUrl = `${CONFIG[settings.region].wsUrl}?model=${settings.model}`;
                    log(`ç›´æ¥è¿æ¥é˜¿é‡Œäº‘`, 'info');
                }
                
                log(`WebSocket URL: ${wsUrl}`, 'info');
                
                // åœ¨ URL ä¸­æ·»åŠ  voice å‚æ•°
                const fullUrl = `${wsUrl}&voice=${encodeURIComponent(voiceId)}`;
                log(`å®é™…è¿æ¥URL: ${fullUrl}`, 'info');
                
                ws = new WebSocket(fullUrl);
                
                const audioChunks = [];
                let sessionCreated = false;

                ws.onopen = () => {
                    log('WebSocket å·²è¿æ¥', 'success');
                    ws.send(JSON.stringify({
                        type: 'session.update',
                        session: {
                            voice: voiceId,
                            response_format: 'pcm',
                            mode: 'server_commit'
                        }
                    }));
                };

                ws.onmessage = (event) => {
                    try {
                        // å¤„ç† Blob ç±»å‹æ•°æ®
                        let dataText;
                        if (event.data instanceof Blob) {
                            log('æ”¶åˆ° Blob æ¶ˆæ¯ï¼Œæ­£åœ¨è½¬æ¢...', 'info');
                            const reader = new FileReader();
                            reader.onload = (e) => {
                                handleMessage(e.target.result);
                            };
                            reader.onerror = (e) => {
                                log('Blob è½¬æ¢å¤±è´¥: ' + e, 'error');
                            };
                            reader.readAsText(event.data);
                            return;
                        } else {
                            dataText = event.data;
                        }
                        handleMessage(dataText);
                    } catch (e) {
                        log(`å¤„ç†æ¶ˆæ¯é”™è¯¯: ${e.message}`, 'error');
                    }
                };

                // å¤„ç†æ¶ˆæ¯çš„ç‹¬ç«‹å‡½æ•°
                function handleMessage(messageText) {
                    try {
                        const data = JSON.parse(messageText);
                        
                        switch(data.type) {
                            case 'session.created':
                                log('ä¼šè¯å·²åˆ›å»º', 'info');
                                log(`Session voice: ${data.session?.voice}`, 'info');
                                sessionCreated = true;
                                // ä½¿ç”¨æ­£ç¡®çš„æ¶ˆæ¯æ ¼å¼ï¼šinput_text_buffer.append
                                ws.send(JSON.stringify({
                                    type: 'input_text_buffer.append',
                                    text: text
                                }));
                                // ç„¶åæäº¤ç¼“å†²åŒº
                                ws.send(JSON.stringify({
                                    type: 'input_text_buffer.commit'
                                }));
                                // ç»“æŸä¼šè¯
                                ws.send(JSON.stringify({
                                    type: 'session.finish'
                                }));
                                break;
                                
                            case 'response.audio.delta':
                                const audioData = base64ToArrayBuffer(data.delta);
                                audioChunks.push(audioData);
                                audioQueue.push(audioData);
                                if (!isPlaying) {
                                    playAudioQueue();
                                }
                                break;
                                
                            case 'response.done':
                                log('åˆæˆå®Œæˆ', 'success');
                                break;
                                
                            case 'session.finished':
                                log('ä¼šè¯ç»“æŸ', 'info');
                                ws.close();
                                if (audioChunks.length > 0) {
                                    const completeAudio = concatenateArrayBuffers(audioChunks);
                                    const wavBlob = pcmToWav(completeAudio, 24000);
                                    const audioUrl = URL.createObjectURL(wavBlob);
                                    document.getElementById('synthesisResult').innerHTML = `
                                        <div class="result-audio">
                                            <div style="color:#2e7d32;font-weight:600;">âœ… åˆæˆå®Œæˆï¼</div>
                                            <audio controls src="${audioUrl}"></audio>
                                            <a href="${audioUrl}" download="synthesis_${Date.now()}.wav" class="btn btn-secondary btn-small" style="margin-top:8px;display:inline-block;text-decoration:none;">ä¸‹è½½éŸ³é¢‘</a>
                                        </div>
                                    `;
                                }
                                btn.disabled = false;
                                btnText.textContent = 'å¼€å§‹åˆæˆ';
                                break;
                                
                            case 'error':
                                log(`é”™è¯¯: ${data.error?.message || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                                btn.disabled = false;
                                btnText.textContent = 'å¼€å§‹åˆæˆ';
                                break;
                                
                            default:
                                log(`æ”¶åˆ°æ¶ˆæ¯ç±»å‹: ${data.type}`, 'info');
                        }
                    } catch (e) {
                        log(`è§£ææ¶ˆæ¯å¤±è´¥: ${e.message}`, 'error');
                    }
                }

                ws.onerror = (error) => {
                    log('WebSocket é”™è¯¯', 'error');
                    log(`é”™è¯¯è¯¦æƒ…: ${JSON.stringify(error)}`, 'error');
                    btn.disabled = false;
                    btnText.textContent = 'å¼€å§‹åˆæˆ';
                };

                ws.onclose = (event) => {
                    log(`WebSocket å·²å…³é—­: code=${event.code}, reason=${event.reason}`, 'info');
                };

            } catch (error) {
                log(`åˆæˆå¤±è´¥: ${error.message}`, 'error');
                btn.disabled = false;
                btnText.textContent = 'å¼€å§‹åˆæˆ';
            }
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = atob(base64);
            const bytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
                bytes[i] = binaryString.charCodeAt(i);
            }
            return bytes.buffer;
        }

        function concatenateArrayBuffers(buffers) {
            const totalLength = buffers.reduce((acc, buf) => acc + buf.byteLength, 0);
            const result = new Uint8Array(totalLength);
            let offset = 0;
            for (const buf of buffers) {
                result.set(new Uint8Array(buf), offset);
                offset += buf.byteLength;
            }
            return result.buffer;
        }

        function pcmToWav(pcmBuffer, sampleRate) {
            const view = new DataView(new ArrayBuffer(44 + pcmBuffer.byteLength));
            const pcmData = new Uint8Array(pcmBuffer);
            
            // RIFF chunk
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmBuffer.byteLength, true);
            writeString(view, 8, 'WAVE');
            
            // fmt chunk
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, 1, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * 2, true);
            view.setUint16(32, 2, true);
            view.setUint16(34, 16, true);
            
            // data chunk
            writeString(view, 36, 'data');
            view.setUint32(40, pcmBuffer.byteLength, true);
            
            const wavData = new Uint8Array(view.buffer);
            wavData.set(pcmData, 44);
            
            return new Blob([wavData], { type: 'audio/wav' });
        }

        function writeString(view, offset, string) {
            for (let i = 0; i < string.length; i++) {
                view.setUint8(offset + i, string.charCodeAt(i));
            }
        }

        async function playAudioQueue() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)({
                    sampleRate: 24000
                });
            }

            isPlaying = true;

            while (audioQueue.length > 0) {
                const buffer = audioQueue.shift();
                const audioBuffer = audioContext.createBuffer(1, buffer.byteLength / 2, 24000);
                const channelData = audioBuffer.getChannelData(0);
                const pcmData = new Int16Array(buffer);
                
                for (let i = 0; i < pcmData.length; i++) {
                    channelData[i] = pcmData[i] / 32768;
                }

                const source = audioContext.createBufferSource();
                source.buffer = audioBuffer;
                source.connect(audioContext.destination);
                
                await new Promise(resolve => {
                    source.onended = resolve;
                    source.start();
                });
            }

            isPlaying = false;
        }
    </script>
</body>
</html>
